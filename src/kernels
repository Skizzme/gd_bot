void atomicAdd_g_f(volatile __global double *addr, double val) {
    union {
        ulong u64;
        double f64;
    } next, expected, current;
    current.f64 = *addr;
    do {
        expected.f64 = current.f64;
        next.f64 = expected.f64 + val;
        current.u64 = atom_cmpxchg((volatile __global ulong *)addr, expected.u64, next.u64);
    } while( current.u64 != expected.u64 );
}

__kernel void forward(int layer_id, int input_length, int weights_offset, __constant double* weights, __constant double* input, __global double* output) {
    int x = get_global_id(0);
    int y = get_global_id(1);
    int w_index = (input_length*x)+y + weights_offset;
    double w = weights[w_index];
    // printf("LAYER: %zu, pos: (%zu, %zu), w_offset: %zu, node_input: %f, w: %f, w_ind: %zu", layer_id, x, y, weights_offset, input[y], w, w_index);
    atomicAdd_g_f(&output[x], input[y]*w);
}

double sigmoid(double val) {
    return 1 / (1 + exp(-val));
}

__kernel void activation(__global double* values) {
    int i = get_global_id(0);
    values[i] = sigmoid(values[i]);
}

__kernel void error(__constant double* values, __constant double* target, __global double* error) {
    int i = get_global_id(0);
    error[i] = target[i]-values[i];
}