
void atomicAdd_g_f(volatile __global float *addr, float val) {
    union {
        unsigned int u32;
        float f32;
    } next, expected, current;
    current.f32 = *addr;
    do {
        expected.f32 = current.f32;
        next.f32 = expected.f32 + val;
        current.u32 = atomic_cmpxchg((volatile __global unsigned int *)addr, expected.u32, next.u32);
    } while( current.u32 != expected.u32 );
}

__kernel void matcher(int x_size, int y_size, __constant float* weights, __constant float* input, __global float* output) {
    int x = get_global_id(0);
    int y = get_global_id(1);
    int loc_x = get_local_id(0);
    int loc_y = get_local_id(1);
    int w_index = (y_size*x)+y;
    // printf("IDS: (%zu, %zu) (%zu, %zu)\n", x, y, loc_x, loc_y);
    atomicAdd_g_f(&output[x], input[y]*weights[w_index]);
}