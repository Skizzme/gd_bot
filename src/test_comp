
void atomicAdd_g_f(volatile __global double *addr, double val) {
    union {
        ulong u32;
        double f32;
    } next, expected, current;
    current.f32 = *addr;
    do {
        expected.f32 = current.f32;
        next.f32 = expected.f32 + val;
        current.u32 = atom_cmpxchg((volatile __global ulong *)addr, expected.u32, next.u32);
    } while( current.u32 != expected.u32 );
}

__kernel void layer(int x_size, int y_size, __constant double* weights, __constant double* input, __global double* output) {
    int x = get_global_id(0);
    int y = get_global_id(1);
    int w_index = (y_size*x)+y;
    atomicAdd_g_f(&output[x], input[y]*weights[w_index]);
}